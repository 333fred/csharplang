# Union Interfaces

## IUnion

### Summary

Union types implement an interface that makes it easy to identify and interact with at runtime when a value that might be a union is weakly typed or represented as a type parameter.

```csharp
object obj = ...;

if (value is IUnion union) 
{
    // don't write union wrapper
    Write(union.Value);
}
else 
{
    Write(value);
}
```

### Motivation

To enable library or utility code that is unaware of application specific union types to become union aware and interact with union values without using reflection.

To provide a means for the compiler to identify union types and access the value of the union with certainty.

### Specification

```csharp
public interface IUnion
{
    // The value of the union or null
    object? Value { get; }
}
```

* The `IUnion` interface is all that is necessary for a type to be considered a union by the language.  
* The `Value` property of the interface is targeted by the compiler to implement pattern matching.
* *Nominal Type Unions* generated by the compiler implement this interface.

### Example

```csharp
public struct MyUnion : IUnion
{
    public MyUnion(Case1 value) { this.Value = value; }
    public MyUnion(Case2 value) { this.Value = value; }

    // implements IUnion.Value
    public object Value { get; }
}
```

## IUnion&lt;TUnion&gt;

### Summary

Unions may implement the `IUnion<TUnion>` to provides a means to construct union instances at runtime when the union type is a constrained type parameter.

```csharp
TUnion ReadUnion<TUnion>() where TUnion : IUnion<TUnion>
{
    object val = ReadValue();

    // wrap the value in the union
    if (TUnion.TryCreate(val, out var union)) 
        return union;

    throw ...;
}
```

### Motivation

To enable library or utility code that is unaware of application specific union types to become union aware and construct union instances from case values at runtime.

### Specification 

```csharp
public interface IUnion<TUnion> : IUnion
    where TUnion : IUnion<TUnion>
{
    // Creates a union from a value
    static abstract bool TryCreate<TValue>(TValue value, [NotNullWhen(true)] out TUnion union);
}
```
* *Nominal Type Unions* generated by the compiler implement this interface.
* Maybe named `IUnionTryCreate` instead?

### Example

Nominal type unions implement both the `IUnion` and `IUnion<TUnion>` interfaces.

```csharp
// lowered MyUnion
public struct MyUnion : IUnion<MyUnion>
{
    public Union(Case1 value) { this.Value = value; }
    public Union(Case2 value) { this.Value = value; }

    // IUnion.Value
    public object? Value { get; }

    // IUnion<MyUnion>.TryCreate
    public static bool TryCreate<TValue>(TValue value, [NotNullWhen(true)] out MyUnion union)
    {
        // handle all known case types and null
        switch (value)
        {   
            case Case1 value1:
                union = new MyUnion(case1);
                return true;
            case Case2 value2:
                union = new MyUnion(value2);
                return true;
            case null when _canBeNull:                
                union = default;
                return true;
            default:
                union = default!;
                return false;
        }
    }

    // precompute if this union can be created with a null value.
    private static readonly bool _canBeNull = 
        default(Case1) == null || default(Case2) == null;
}
```

* *Note*: it is also valuable for a union type to provide a public means to construct another instance when the union type is fully understood, but the value is not.

```csharp
object? value = ReadValue();

// if not type-safe certain that value is a case type, use TryCreate.
if (MyUnion.TryCreate(value, out MyUnion union))
{
    ...
}
```

## IUnionUnboxed

* Needs better name!

### Summary

Unions with custom layouts may implement the `IUnionUnboxed` to provide an alternate means of accessing the union's value without boxing struct values.

```csharp
public void TryWrite<TUnion, TCase>(TUnion union) where TUnion : IUnionUnboxed
{
    if (union.TryGetValue(out TCase value))
        Write<TCase>(value);
}
```

### Motivation

Custom unions will exist that provide alternate storage layouts that are not boxed object references. This implies there may be situations where a user limited to interacting via interfaces may desire to avoid boxing when accessing the union's value. 

### Specification

```csharp
public interface IUnionUnboxed : IUnion
{
    // True if the union has a non-null value
    bool HasValue { get; }

    // Gets the value of the union if it is the specified type.
    bool TryGetValue<TValue>([NotNullWhen(true)] out TValue value);
```

* If this interface exists for a union, the compiler may target its members for pattern matching.
* Maybe named `IUnionTryGetValue` or `IUnionNonBoxing` or `IUnionEx`.

### Example

```csharp
public struct MyCustomUnion : IUnionUnboxed
{
    private readonly int _kind;
    private readonly Case1 _case1;
    private readonly Case2 _case2;

    public MyCustomUnion(Case1 value)
    {
        _kind = value == null ? 0 : 1;
        _case1 = value;
    }

    public MyCustomUnion(Case2 value)
    {
        _kind = value == null ? 0 : 2;
        _case2 = value;
    }

    // IUnion.Value 
    public object Value =>
        _kind switch 
        {
            1 => _case1,
            2 => _case2,
            _ => null
        };

    // IUnionUnboxed.HasValue
    public bool HasValue => _kind != 0;

    // IUnionUnboxed.TryGetValue
    public static bool TryGetValue<TValue>([NotNullWhen(true)] out TValue value)
    {
        switch (_kind)
        {
            case 1 when _case1 is TValue tcase1:
                value = tcase1;
                return true;
            case 2 when _case2 is TValue tcase2:
                value = tcase2;
                return true;
            default:
                value = default!;
                return false;
        }
    }
}
```

